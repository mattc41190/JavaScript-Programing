<!DOCTYPE html>
<html>
<head>
	<title>Learning HTTP</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css">
	<link rel="stylesheet" href="../Styles/MainStyle.css">
	<link rel="stylesheet" type="text/css" href="../Styles/ContextMenuStyle.css">
</head>
<body>
<a href="#HTTPTitle"><div id="contextMenu">
	<p id="caret"><strong>^</strong></p>
</div></a>
<div class="jumbotron" id="HTTPTitle">
<h1>HTTP</h1>
<a href="../Index.html"><button class="btn btn-default">Home</button></a></div>
</div>
<div class="container">
	<div id="HTTPIndex">
		<div class="well">
			<h2>
				HTTP Concepts
			</h2>
			<p>Though this site is primarily dealing with JavaScript there are still some essential bits of knowledge required to create production level JavaScript code. Specifcally concerning the creation, use, and re-use of HTML5 Web Components.</p>
			<p>This page will walk you through some of the basics of Hyper Text Transfer Protocol or HTTP.</p>
			<ol>
			<li><a href="#httpResources">HTTP Resources</a></li>
			<li> <a href="#httpMessages">HTTP Messages</a></li>
			<li><a href="#httpConnections">HTTP Connection</a></li>
			<li> <a href="#httpArchitecture">HTTP Architecture</a></li>
			<li> <a href="#httpSecurity">HTTP Security</a></li>
			</ol>
		</div>
	</div> <!-- EndOf_HTTPIndex -->
	<div id="HTTPResources">
		<div class="well">
		<h2 id="httpResources">HTTP Resources</h2>
		<p>HTTP stands for Hyper Text Transfer Protocol. It is the means by which resources on the internet are found and used. This unit covers the resources on the internet and how they are accessed via the HTTP protocol.</p>
		<ol>
			<li><a href="#URLSection">Uniform Resource Locators</a></li>
			<li><a href="#PQFSection">Ports, Queries, & Fragments</a></li>
			<li><a href="#URLEncodingSection">URL Encoding</a></li>
		</ol> 
		</div>
		<div class="well">
		<h3 id="URLSection">Uniform Resource Locators</h3>
		<p>HTTP Requests are made via a URL or a Uniform Resource Locator. A URL is composed 3 basic parts. The first part is the URL scheme, when a website is being accessed it's scheme is <code>HTTP://</code> this specifices what type of protocol is needed to return to the desired resource. <i>Note: There are other protocols available in the browser such as the FTP or File Transfer Protocol or the MailTo E-Mail Protocol. For now we will only be discussing HTTP/HTTPS</i></p>
		<p>The second part of a URL is the host. The host is the name of the location the browser will use to look for a specific resource. For example,<code>www.ExampleWebsite.com</code>. This part of the URL points to a literal machine somehwere that is hosting the desired resource. The host name or domain name is an alias for the IP address, so the first thing a request does is a look up of the host name and translates that into an IP address of a specific machine somewhere.</p>
		<p>The last part of the URL is known as the path. The path looks very similiar to file path on your local machine and very often the browser is pointing to a real file somewhere. For example:<br> <code>www.ExampleWebsite.com/HtmlExamples/HelloWorld.html</code>.<br>
		In other cases the URL is requesting a resource to be rendered against a template and the file itself doesn't exist but all the pieces required to make the file do. This approach leads to more uniform URLs that will not deprecate as easily overtime. </p>

		<br>
		<h4>Example:</h4>
		<code>http://www.ExampleWebsite.com/HtmlExamples/HelloWorld.html</code>
		<br>
		<p>The URL above is making an http request to a host at www.ExampleWebsite.com. The specfic resource desired is placed in the path and points to an actual HTML file called HelloWorld.html</p>
		</div> <!-- EndOf_URLSection -->
		<div class="well">
		<h3 id="PQFSection">Ports, Queries, and Fragments</h3>
		<p>While the URL is composed of three major parts, there are additional elements a URL can contain. Three additional URL components are Ports, Queries, and Fragments.</p>
		<p>Ports are addresses where the host will listen for HTTP requests. Ports are a default part of the URL and if none is specified as is usually the case the port defaults to 80. The port is located after the host name, and before the path. <code>http://www.ExampleSite.com:80/HelloWorld/Hello.html</code>.</p>
		<p>Though the default port of 80 does not need to be specified if it is modified to be something besides 80 it will be a required portion of the URL from then on.</p>
		<p>Queries or query strings are located at the end of a path and typcally help point to a more specific resource on a page. Queries are largely self explanatory. <code>http://www.ExampleSearch.com/search?q=book</code>. The preceeding URL is the result of looking for <kbd>book</kbd> in the ExampleSearch websites search action. The query string is 100% determined by the application, but conventionally the query string appears in a name value pair system. In the section above the search action takes a query called "q" and in the example above q is equal to "book" so the search action runs against book.</p>
		<p>Fragments are located at the very end of any URL and they are not processed on the server side like any other portions of the URL. The fragment is marked by a <code>#</code> followed by the desired page fragment. When a fragment is processed by the client the page jumps to or loads at the specific fragment of the page specified. For instance: <code>https://en.wikipedia.org/wiki/Fragment_identifier#Proposals</code> will bring the user to a Wikipedia page, but furthermore it will bring them to a specifc portion/fragment of the page identified by the world "Proposals"</p>
		<br>
		<p>At this point we have covered all major areas of the URL. From the all important scheme, to the helpful addition fragment. Being given the following URL <code>http://www.HostSite.com:81/path?q=name#frag</code> you should be able to correctly identify all of its constiuent parts and explain what they do.</p>
		</div>
		<div class="well">
		<h3 id="URLEncodingSection">URL Encoding</h3>
		<p>The characters used to create URLs have been carefully selected and the rules surrounding what types of characters are allowed in a URL are important to know. This section covers how URLs are encoded and the rules regarding what characters may be used.</p>
		<p>To give an example of a character that is not considered a "safe" URL character consider the space character. It is a highly utilized character, and makes sentences look much better. For instance,iamasupercoolwebsitename.com/thisisasuperlongconfusingpath is much easier to read as: i am a super cool website name.com/this is a super long confusing path. However, imagine the confusion a user might run into if he or she had accidentally placed two space in the URL or had mistakenly thought there were two space in the URL he or she read. For this reason, there are standard regarding URL characters.</p>
		<p>For quick reference consider the character A-Z, a-z, and 0-9 to be safe. Special character that are also conisdered safe are: $-_.+!*'(). Everything else is either resevered for URL structure reasons (the use of <kbd>#</kbd> is reserved to denote a page fragment for instance) or requires special encoding (the caret symbol for instace <kbd>^</kbd>)</p>
		<p>If at any point encoding is required, then it must be encoded via percent encoding/ URL encoding. URL/Precent encoding is the process of translating certain special characters to their reserved percent sign preceeding translation. For instance the URL <code>http://www.Test Website.com</code> needs to be encoded as <code>http://www.Test%20Website.com</code> becuase the URL encoded version of the <kbd>Space</kbd> is "%20".</p>
		<p>For full encoding direction please visit <a href="http://www.w3schools.com/tags/ref_urlencode.asp">W3 Schools</a>.</p>
		</div>
	</div> <!-- EndOf_HTTPResources -->
	<div id="HTTPMessages">
		<div class="well">
		<h2 id="httpMessages">HTTP Messages</h2>
		<p>HTTP relies on the sending of messages from the server to the client and from the client to the server. This units covers what types of messages exist, what thet are used for, and the composition of a message being sent and the composition of the response.</p>
		<ol>
			<li><a href="#MethodsSection">HTTP Methods</a></li>
			<li><a href="#RequestSection">Request Messages</a></li>
			<li><a href="#ResponseSection">Response Messages</a></li>
		</ol> 
		<br>
		</div>
		<div class="well">
		<h3 id="MethodsSection">HTTP Methods</h3>
		<p>There are several HTTP methods and every HTTP request made to a server must contain an acceptable method. In this section we will only cover two methods in depth,the GET method and the POST method. Other methods that you might see are <code>DELETE</code> which removes a resource, <code>PUT</code> which stores a resource, and <code>HEAD</code> which retrieve the headers for a resource. Don't be scared if this doesn't make sense right away. The major concepts will be explained in depth and from a beginner's point of view</p>
		<ol>
			<li><a href="#GetSubSection">GET</a></li>
			<li><a href="#PostSubSection">POST</a></li>
		</ol> 
		<br>
		</div>
		<div class="well">
		<h4 id="GetSubSection">GET</h4>
		<p>The <code>GET</code> HTTP method does exactly what it sounds like. It gets a resource from the server. Without knowing it anytime you request a resource (remember a resource could be anything from a picture, to a video, to a web page) you are sending an HTTP <code>GET</code> method along with your URL. The <code>GET</code> method is considered a "safe" method because it does not affect data or change anything on the side of the server which serves not only your user but all other user asking for resources from that host.</p>
		<br>
		</div>
		<div class="well">
		<h4 id="PostSubSection">POST</h4>
		<p>The <code>POST</code> HTTP method updates data on a server from a client. Without knowing it anytime you submit a data to a server you are sending an HTTP <code>POST</code> method along with your URL. For example, if you register for a site or add an item to your basket in amazon you are issuing a <code>POST</code> request to a server and data has now changed on the server side. Typically posts are submitted via the HTML form element <br><code>&ltform method="post"&gt</code>.
		<br>
		 The <code>POST</code> method is considered to be unsafe due to the fact that it is modifying data on the server and has the potential to create harmful or inaccurate data. <code>POST</code> methods are used for operations like processing credit card transactions and registering information on a website. Due to the unsafe nature of the post method several browsers warn the user that doing certain actions is considered unsafe.</p>
		 <p>Quite often in order to prevent users from completeing potentially harmful actions they will instead be redirected if the page is the result of a <code>POST</code> to a page whose HTTP method is a <code>GET</code>. This method is called PostRedirectGet or PrG.</p>
		<br>
		</div>
		<div class="well">
		<h3 id="RequestSection">Request Messages</h3>
		<p>An HTTP request message includes the HTTP method (a GET or POST), a URL, and a version (HTTP v1.1 has been in use since 1998) <i>[method][URL][version]</i>. This portion of the message is called the start line and is always in ascii text.</p>
		<p>The second portion of a request message is called the headers and finally the body of the message. The headers section contains information required by the server (Ex: The URL Host) or useful for content negotiation (Ex: Langauge preference). In the table below is a list of common headers and their uses.</p>
		<table class="table table-hover">
			<tr class="info">
				<th>Header</th>
				<th>Description</th>
			</tr>
			<tr>
				<td>Host</td>
				<td>Host of the site from which the request is being made.</td>
			</tr>
			<tr>
				<td>Referer</td>
				<td>The URL of the referring page.</td>
			</tr>
			<tr>
				<td>User-Agent</td>
				<td>Browser information.</td>
			</tr>
			<tr>
				<td>Accept</td>
				<td>Preferred media types aka MIME types (Ex: text/html or jpeg).</td>
			</tr>
			<tr>
				<td>Accept-Language</td>
				<td>Preferred.</td>
			</tr>
			<tr>
				<td>Cookie</td>
				<td>Cookie information.</td>
			</tr>
			<tr>
				<td>If-Modified-Since</td>
				<td>Date of last retrieval.</td>
			</tr>
			<tr>
				<td>Date</td>
				<td>Creation timestamp for the message.</td>
			</tr>
		</table>
		<br>
		A full HTTP request message might look like the following:
		<br>
		<code>
			GET / www.example.com HTTP/1.1<br>
			Host: ExampleServer.com<br>
			Connection: keep-alive<br>
			User-Agent: Mozilla/5.0<br>
			Accept: text/html<br>
			Referer: http://www.goodle.com<br>
		</code>
		</div>
		<div class="well">
			<h3 id="ResponseSection">Response Messages</h3>
			<p>An HTTP response message will contain a Version, a Status Code, and a Reason. The version will be the same HTTP version number that the request has it just happens to come first in the response. The status code which is layed out below will be a number indicating the type of response the HTTP resource is giving you. The reason will be a short explnation of the status code.</p>
			<p>The HTTP response, like the request also has the ability to send back Headers and a Body. The headers are information on the response it may have information on the server that is sending the response, the date the response was created. In addition there are extender headers demarcated by the letter X- preceeding the header. On example of an extended header is the X-Powered-By which is a microsoft header that will inform the user of the type of microsoft tech being used to return the result. The body is the returned resource itself.</p>
			<p>A full HTTP response might look like the following:</p>
			<br>
			<code>
				HTTP/1.1 200 OK<br>
				Content-Type: text/xml; charset=utf-8<br>
				Content-Length: 1771<br>

				<br>&lt?xml version="1.0" encoding="utf-8"?&gt<br>
				&ltsoap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt<br>
				  &ltsoap:Body&gt<br>
				  &ltEnlightenResponse xmlns="http://clearforest.com/"&gt<br>
				  &ltEnlightenResu&ltgtstring&lt/EnlightenResu&ltgt<br>
				  &lt/EnlightenResponse&gt<br>
				  &lt/soap:Body&gt<br>
				&lt/soap:Envelope&gt<br>
			</code>
			<br>
			<p>The response specifies that it uses the HTTP 1.1 protocol. It is returning a status of 200 and an explanation of that that stauts which is "OK". The content-type and content-length are the only headers included in this response the content type tell the client that it is returning XML with the UTF-8 char set. The body as specified in the MIME/content type is an XML document.</p>
			<table class="table table-hover">
				<tr class="info">
					<th>Status Code Range</th>
					<th>Explanation</th>
					<th>Popular Example</th>
				</tr>
				<tr>
					<td>100-199</td>
					<td>Informational</td>
					<td></td>
				</tr>
				<tr>
					<td>200-299</td>
					<td>Successful</td>
					<td>200, the resource is returning as expected</td>
				</tr>
				<tr>
					<td>300-399</td>
					<td>Redirection</td>
					<td>301, tells the browser theis resource has been moved elsewhere permanently</td>
				</tr>
				<tr>
					<td>400-499</td>
					<td>Client Error</td>
					<td>404, the resource was not found where the client is looking</td>
				</tr>
				<tr>
					<td>500-599</td>
					<td>Server Error</td>
					<td>500, internal server error means logic on the server side failed to return the appropriate resource.</td>
				</tr>
			</table>
		</div>
	</div> <!-- EndOf_HTTPMessages -->
	<div id="HTTPConnections">
		<div class="well">
		<h2 id="httpConnections">HTTP Connections</h2>
		<p>While HTTP is the means by which an application commuincates with another application or different side of the same application (HTTP is often refered to as an application layer protocol). There are others "layers" that help transport HTTP messages from clients to servers. This section goes over those layers, what they are responsible for, and when they are available.</p>
		<ol>
			<li><a href="#TCPSection">Introduction to TCP</a></li>
			<li><a href="TCPHandshake">TCP Handshake</a></li>
		</ol>
		</div>
		<div class="well">
		<h3 id="TCPSection">Transmission Control Protocol</h3>
		<p>The Transmission Control Protocol or TCP is a reliable protocol that is a layer below the HTTP protocol and its responsiblity is to take information from an HTTP request and send it to the desired server. When a client side browser wants to meake request it extracts the host and determines the IP address for that host. The browser thens opens a TCP socket and begins writing data into that socket. The browsers only responsiblity is to write the correct data into the TCP socket. Once the information is written TCP takes the message and ensure that the message makes it way to the server without being lost, corrupted, or duplicated. TCP automatically resends any data that might get lost in transit and for this reason it is a relaible protocol. In addition TCP provides flow control so that devices don't get flooded with too much data all at once.</p>
		<p>While HTTP and TCP are the primary focuses of this section it will be benefical to name the other players in the game. Once the message are stored by TCP they are handed to Internet Protocol or IP which directs the messages over all the physical devices via their IP address. The last layers is the truly physicaly layer known as the data link layer whch may be cable, ethernet or wireless.</p>
		</div>
		<div class="well">
		<h3 id="TCPHandshake">TCP Handshake</h3>
		<p>The TCP handshae is a process that the browser and intended server do before any HTTP messages are ever sent. The handshake is a collection of three messages that opens a connection to a server. The steps below occur any time a resource is desired froma website. As soon as you hit enter to go to www.google.com before any resources are requested or retrieved the handshake occurs.</p>
		<p>
			Host A (client/browser) sends a <kbd>TCP SYNchronize</kbd> (known as a SYN) packet to Host B<br>
			Host B receives A's <kbd>SYN</kbd><br>
			Host B sends a <kbd>SYNchronize-ACKnowledgement</kbd> (known as a SYN-ACK)<br>
			Host A receives B's <kbd>SYN-ACK</kbd><br>
			Host A sends <kbd>ACKnowledge</kbd><br>
			Host B receives <kbd>ACK</kbd>. <br>
			TCP socket connection is ESTABLISHED.<br>
			</p>
		</div>
	</div> <!-- EndOf_HTTPConnections -->
	<div id="HTTPArchitecture">
		<div class="well">
		<h2 id="httpArchitecture">HTTP Architecture</h2>
		<p>HTTP as a whole is primarily about sending a message from one machine to another machine and then interpretting the response. There are a number of ways in which someone might leverage the capablities of HTTP messages to serve their website.In this section we will be primarily concerned with proxies and caching and how they relate to the way an application preforms.</p>
		<ol>
			<li><a href="#Proxies">Proxy Server</a></li>
			<li><a href="#Caching">Caching</a></li>
		</ol>
		</div>
		<div class="well">
			<h3 id="Proxies">Proxy Server</h3>
			<p>A Proxy server is a server that intercepts HTTP messages and either redirects them or modifies them if needed. There are two different main types of proxies; the forward proxy and the reverse proxy. A forward proxy will intercept messages close to the client and redcirect them or hold on to them. One commonly used feature for the forward proxy is the intercepting of messages heading to websites that an employer doesn't want his employees visiting on the company network. A forward proxy can intercept a message for facebook and redriect it to fail and in so doing block employees from that site. In addition, a forward proxy can modify and remove potentially dangerous data like the referer URL. A reverse proxy on the other hand will live closer to the server and tends to be there to ensure performance from the server side. A server side proxy can act as a load balancer if for instance there were two main website servers and one had a great deal of pressure on it a load balancer could begin to redirect HTTP messages to the server with more available memory and resources. Both sorts of proxies employ a technique known as caching to improve performance.</p>
		</div>
		<div class="well">
			<h3 id="Caching">Caching</h3>
			<p>Caching is the method of holding on to a resource for use later. The client, server, and proxies can take advantage of this technique. Commonly there resources that once downloaded are not modified for sometime, but are large, expensive, and loaded several times a day. An example of this is the large "Google" picture on Google's home page. That page is loaded several times a day and it rarely changes. Once a client retrieves that resource once it is safe to store/ cache it for later use. Later that day if the page is reloaded instead of requesting the resource again from the server the browser can scan the cache for resources from that URL and place them in the page. This method drastically improves performance.</p>
		</div>
	</div> <!-- EndOf_HTTPArchitecture -->
	<div id="HTTPSecurity">
		<div class="well">
		<h2 id="httpSecurity">HTTP Security</h2>
		<p>The beauty of HTTP is that it is a stateless protocol. When the term stateless is used it means that all of the information needed to complete a full HTTP transcation occurs in every request and response. For this reason the fully verbose version of the messages are sent accross the wire for every request (if resource is cached it is not sent unless told to). This stateless measure while very good for serving static information is at odds with our personalized and highly stateful applications. This issue is fixed with HTTP security methods. This section goes over some of the techniques used to provice application state via a stateless protocol.</p>
		<ol>
			<li><a href="#NonCookieMethods">Non-Cookie Methods</a></li>
			<li><a href="#CookieMethods">Cookies</a></li>
			<li><a href="#Authentication">Authentication</a></li>
			<li><a href="#HTTPS">HTTPS</a></li>
		</ol>
		</div>
		<div class="well">
		<h3 id="NonCookieMethods">Non-Cookie Methods</h3>
		<p>While a great deal of this unit is dedicated to storing state within cookies there are other methods for storing the state of a resource.</p>
		<p>One simple method is to save information about the specific resource in hidden inputs on the page itself. ASP does excatly this in its <code>__ViewState</code> method. The information dealing with a users current state is saved into a string and is sent up to the server to be retrevied in its former state the next time it is needed. A problem with this is that it can become confusing with large scale apps.</p>
		<p>Another method of storing state is to store the state of data in a database to be retreived when that specific resource is needed again. When the data is saved to a database the next time it is needed it will be pulled as part of the HTTP request.</p>
		<p>Outside of pure cookies there is one other highly used method of storing state. In ASP.NET applications access to the Session object is available. The session object will store information on a specific user's interaction with the site. It is based on the cookie method so if cookies are disabled the session object will not work. For more information on the session object click <a href="http://webcheatsheet.com/asp/session_object.php">here</a></p>
		</div>
		<div class="well">
		<h3 id="CookieMethods">Cookie Methods</h3>
		<p>Outside of the methods previously described there is the most common way of storing session state and that is via the HTTP cookie. The cookie is sent from the website in the form of a response message with an identifier of some sort (typically a GUID)
		<br>
		<code>
			HTTP/1.1 200 OK<br>
			Set-Cookie: GUID=00a48b7f6a4946a8adf593373e53347c;<br>
            domain=.msn.com; path=/<br>
		</code>
		 and this is stored on the client's side and sent back and forth in the HTTP messages to indicate the user's session state. The cookie may be associated to an in app data structure or information in the DB so that the user's previous state is always able to be returned from the browser as soon as it is needed.</p>
		 <p>Cookies have potential vulnerablities as they are visible to anyone on the network and may be intercepted and hijacked. Additionally any message with cookie information cannot be cached.</p>
		</div>
		<div class="well">
		<h3 id="Authentication">Authentication</h3>
		<p>There a several forms of authetication, from basic, to digest, to Windows Forms to OpenID forms. In this section we will only cover basic as the work we will be doing only covers that area.</p>
		<p>With Basic authentication, the client will first request a resource with a normal HTTP message.
		<br>
			<code>GET http://localhost/html5/ HTTP/1.1<br>
			Host: localhost</code>
		<br>
			Web servers will let you configure access to specific files and directories. You can allow access to all anonymous users, or restrict access so that only specific users or groups can access a file or directory. For the request above, let's imagine the server is configured to only allow certain users to view the /html5/ resource. In that case, the server will issue an authentication challenge.
		<br>
			<code>HTTP/1.1 401 Unauthorized<br>
			WWW-Authenticate: Basic realm="localhost"</code>
		<br>
			The 401 status code tells the client the request is unauthorized. The WWW-Authenticate header tells the client to collect the user credentials and try again. The realm attribute gives the user-agent a string it can use as a description for the protected area. What happens next depends on the user-agent, but most browsers can display a UI for the user to enter credentials.

			With the credentials in hand, the browser can send another request to the server. This request will include an Authorization header.
		<br>
			<code>
			GET http://localhost/html5/ HTTP/1.1<br>
			Authorization: Basic bm86aXdvdWxkbnRkb3RoYXQh</code>
		<br>
			The value of the authorization header is the client's username and password in a base 64 encoding. Basic authentication is insecure, because anyone with a base 64 decoder who can view the message can steal a user's password. For this reason, basic authentication is rarely used without using secure HTTP. It's up to the server to decode the authorization header and verify the username and password with the operating system, or whatever credential management system is on the server. If the credentials match, the server can make a normal reply. If the credentials don't match, the server should respond with a 401 status again.</p>
		</div>
		<div class="well">
		<h3 id="HTTPS">HTTPS</h3>
		<p>Normally, HTTP messages are sent in plain text which helps a great deal when decoding and learning about what is being sent and how it affects the end user experience, however there are cases in which we want to keep information private. For instance, a password stored in Basic Authetication may be decoded from Base64 and seen in plain text. HTTPS encrypts the HTTP message before it hits the TCP layer and therefore before it can be intercepted. It is decoded only after it reaches a server with a certificate. By doing this it remains secure over the wire and is safe from hijackers.</p>
		</div>
	</div> <!-- EndOf_HTTPSecurity -->
</div>
</body>
</html>